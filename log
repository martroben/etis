# standard
import logging

def latinized(logger: logging.Logger) -> None:

    if not "log_latinized" in globals():
        return

    row_width = 50
    latinized_entries = globals()["log_latinized"]

    latinized_rows = list()
    for entry in latinized_entries:
        entry_string = f"| {repr(entry[1]) :<{row_width-2}} | {repr(entry[2]) :<{row_width-2}} |"
        if entry[0] and entry_string not in latinized_rows:
            latinized_rows += [entry_string]

    latinized_header = f"\nTHE FOLLOWING CYRILLIC NAMES WERE TRANSLITERATED TO LATIN:\n"\
    f"+{'':-<{row_width}}+{'':-<{row_width}}+\n"\
    f"| {'original cyrillic':<{row_width-2}} | {'latinized replacement':<{row_width-2}} |\n"\
    f"+{'':-<{row_width}}+{'':-<{row_width}}+"

    logger.info(latinized_header)
    for row in latinized_rows:
        logger.info(row)
    logger.info(f"+{'':-<{row_width}}+{'':-<{row_width}}+")


def parse_fail(n_total: int, logger: logging.Logger) -> None:

    if not "log_parse_fail" in globals():
        return
    
    logger = logging.getLogger("etis")

    row_width = 50
    parse_fail_entries = globals()["log_parse_fail"]
    n_failed_entries = len(parse_fail_entries)

    parse_fail_rows = list()
    for entry in parse_fail_entries:
        entry_string = f"| {repr(entry[0]) :<{row_width-2}} | {str(entry[1]) :<{row_width-2}} |"
        if entry[0] and entry_string not in parse_fail_rows:
            parse_fail_rows += [entry_string]

    parse_fail_header = f"\nCOULD NOT PARSE AUTHORS FROM FOLLOWING ENTRIES\n"\
    f"({round(n_failed_entries / n_total * 100)} % of {n_total}. {len(parse_fail_rows)} unique entries):\n"\
    f"+{'':-<{row_width}}+{'':-<{row_width}}+\n"\
    f"| {'raw authors string':<{row_width-2}} | {'cleaned authors string':<{row_width-2}} |\n"\
    f"+{'':-<{row_width}}+{'':-<{row_width}}+"

    logger.info(parse_fail_header)
    for row in parse_fail_rows:
        logger.info(row)
    logger.info(f"+{'':-<{row_width}}+{'':-<{row_width}}+")
